# java面试题目总结

## java基础

1. 面向对象和面向过程的区别

  - 面向过程：

    优点：性能比面向对象高，因为类调用的时候，需要实例化，开销比较大，比较消耗资源，单片机，嵌入式开发，linux一般采用面向过程开发，性能是最重要的因素；
    缺点：没有面向对象易维护，易复用，易拓展；

  - 面向对象：

    易维护，易复用，易拓展，由于面向对象有封装，继承，多态性的特性。可以设计低耦合的系统，是系统更加灵活，更加易于维护；缺点：性能比面向过程低。

2. java的四个基本特性（抽象、封装、继承、多态）

  - 抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象一个是过程抽象。数据抽象也就是对象的属性，过程抽象是对象的行特征。
  - 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装和隐藏。封装分为属相的封装和方法的封装
  - 继承：是对有着共同特性的多项事物，进行再抽象一个类，这个类就是多项事物的父类。父类的意义在于抽取多类事物的共性；子类可以继承父类的特征和行为，使得子类对象对象（实例）具有父类的实例域和方法，或子类从父类的继承方法，使得子类具有父类相同的行为
  - 多态：允许不同类的对象对同一消息做出响应。方法的重载，类的覆盖体现了多态

3. Overload和Override的区别

  - 重载（Overload）：发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
  - 重写（Override）：发生在父子类，方法名，参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写

4. 构造器Constructor是否可以被override
  构造器不能被重写，不能用static修饰构造器，只能用public private protected 这三个权限修饰符。且不能有返回语句

5. 访问控制符public、protected、private、以及默认的区别

  - private只能在本类中才可以访问；
  - public在任何地方都可以访问
  - protected在同包内的类及包外的子类能访问
  - 默认不写在同包内可以访问
  - 排序：public>protected>default>private

6. 是否可以继承string类
  String类是final类故不能继承，一切由final修饰过的都不能继承

7. String和StringBuffer、StringBuilder的区别

  可变性

  - String类使用字符串数组保存字符串，private final char value[] 所以string对象是不可变的
  - StringBulider和StringBuffer都继承自AbstractStringBuffer类，在AbstractStringBuffer中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的

  线程安全性

  - String中对象是不可变的，也就可以理解为常量，线程安全
  - AbstractStringBuffer是StringBulider和StringBuffer的公共父类，定义了一些字符串的基本操作，StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的，StringBulider并没有对方法加同步锁，所以是非线程安全的

8. hashCode和equals方法的关系
  equals()反应的是对象或者变量具体的值，即两个对象里面包含的的值，可能是对象的引用，也可能是值类型的值。而hashcode()是对象或者变量通过哈希算法计算出的哈希值
  equals相等，hashcode必相等，hashcode相等，equals可能不相等

9. 抽象类和接口的区别

  - 语法层次：不同的语法定义
  - 设计层次：抽象层次不同，抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类进行抽象，包括属性、行为，但是接口是对类局部（行为）的抽象
  - 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行
  - 抽象类的成员变量可以是各种类型的，而接口中的成员变量只能是public static final 类型的
  - 接口中不能含有静态代码块以及静态方法的，而抽象类是可以有静态代码块和静态方法
  - 一个类只能继承一个抽象类，而一个类可以实现多个接口

10. 自动装箱与拆箱
  装箱：将基本类型用他们对应的引用类型包装起来
  拆箱：将包装类型转换为基本的数据类型：
  java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱操作

11. 什么是泛型、为什么要使用以及泛型擦除
   - 泛型，即参数化类型，该集合只能保存其指定类型的元素，避免使用强制类型转换
   - java编译器生成的字节码是不包含泛型信息的，泛型类型信息将在编译处理时候被擦除，这个过程即类型擦除。泛型擦除可以简单理解为将泛型java代码转换为普通java代码，只不过编译器更直接一点，讲泛型java代码直接转换为普通java字节码
   - 类型擦除的主要过程:1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换；2.移除所有的类型参数

12. java中的集合类以及关系图

   set无序不允许元素重复，HashSet和TreeSet是两个主要的实现类

   List有序且允许元素重复。ArrayList、LinkList和Vector是三个主要的实现类

   Map也属于集合系统，但和Collection接口没关系。Map是key对value的映射集合，其中key类就是一个集合，key不能重复，但是value可以重复，HashMap、TreeMap和HashTable是三个主要实现的类

   SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序

13. HashMap实现原理

14. HashTable实现原理

15. ArrayList和vector区别

16. ArrayList和vector区别
   arrayList和Vector都实现了list接口，都是通过数组实现的
   Vector是线程安全的，而Arraylist是非线程安全的
   list第一次创建的时候，会有一个初始大小，随着不断向List增加元素，当list认为容量不够的时候就会进行扩容，vector缺省情况下自动增长为原来一倍的数组长度，ArrayList增长为原来的50%

17. ArrayList和LinkList区别以及使用场景
   - ArrayList底层是使用数组实现的，可以认为ArrayList是一个可以改变大小的数组，随着越来越多的元素被添加到ArrayList中，其规模是动态增加的
   - LinkList底层是通过双向链表实现的，LinkList和ArrayList相比，增删的速度比较快，但是查询和修改值的速度较慢。同时，LinkList还实现可Queue接口，所以提供了offer()（添加一个元素并并返回tu）,peek()（返回队列头部的元素）,pool()（移除并返回队列头部的元素）等方法
   - LinkList更适合从中间插入或者删除（链表的特性），ArrayList更适合检索和在末尾插入和删除（数组的特性）

18. Collection和Collections的区别
   java.util.Collection是一个集合接口，他提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供可最大化的统一的操作方式。
   java.util.Collections是一个包装类，他包含各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于java的Collection框架

19. Concurrenthashmap实现原理

20. Error、Exception区别
   Error和Exception类的父类都是throwable类，区别是：

   - Error一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议是让程序停止
   - Exception类表示程序可以处理的异常，可以捕获且可能恢复，遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常

21. UncheckedException和Checked Exception，各列举几个
   UncheckedException

   - 指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复
   - 包括Error与RuntimeException及其子类，如OutOfMemoryError（内存溢出），UndeclaredThrowableException，IllegalArgumentException（传递了不合法的参数），IllegalMonitorStateException（违法的监控异常,当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常),NullPointerException(空指针异常)，IllegalStateException（无效的状态异常），IndexOutOfBoundsException（数组越界）
   - 语法上不需要声明抛出异常

   Checked Exception：

   - 代表程序不能直接控制的无效的外界的情况（如用户输入，数据库问题，网络异常，文件丢失等）
   - 除了Error和RuntimeException及其子类之外，如ClassNotFoundException（无法找到的类的异常），NamingException（数据源配置异常），ServletException，SQLException，IOException等
   - 需要try catch处理或者throws声明抛出异常

22. java中如何实现代理机制（JDK,CGLIB)

23. 多线程实现方式
   继承Thread类，实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程

24. 线程的状态转换

25. 如何停止一个线程

26. 什么是线程安全
   线程安全就是多线程访问同一代码，不会产生不确定的结果

27. 如何保证线程安全

   - 对非安全的代码进行枷加锁控制
   - 使用线程安全的类
   - 多线程并发的情况下，线程共享的变量改为方法级的局部变量

28. Synchronized如何使用
   Synchronized是java中的关键字，是一种同步锁，它修饰的对象有以下几种：

   - 修饰一个代码块，被修饰的代码块被称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象


   - 修饰一个方法，被修饰的代码称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象
   - 修饰一个静态方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象
   - 修改一个类，其作用的范围是synchronize后面括号括起来的部分 ，作用主的对象是这个类的所有对象

29. synchronized和Lock的区别
   主要相同点：Lock能完成synchronize所实现的所有功能
   主要不同点：Lock有比synchronize更精准的线程语义和更好的性能，Lock的锁定是通过代码实现的，而synchronize是在JVM层面实现的，synchronize会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如他的tryLock方法可以非阻塞方式去拿锁，Lock锁的范围有局限性，块范围、而synchronize可以锁住块、对象、类

30. 多线程如何进行信息交互
   - void notify()唤醒此对象监视器的等待的单个线程
   - void notifyAll() 唤醒在此对象监视器等待的所有的进程
   - void wait() 导致当前的线程等待，直到其他线程调用此对象的notity()方法或者notifyAll()方法
   - void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。
   - void wait(long timeout,int nanos)导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。

31. sleep和wait的区别（考察的方向是是否会释放锁）
   - sleep()方法是Thread类中方法，而wait()方法是object方法
   - sleep方案导致了程序暂停执行指定的时间，让出cpu给其他线程，但他的监控状态依然保持着，当指定的时间到了又会自动恢复到运行状态，在调用sleep方法的过程中，线程不会释放对象锁。而调用wait方案的时候，线程会释放对象锁，进入等待此对象的等到锁定池，只有针对此对象调用notify方法后本线程才进入对象锁定池准备

32. 多线程与死锁
   死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法进行下去
   产生死锁的原因：因为系统资源不足；进程运行推进的顺序不合适；资源分配不当

33. 如何才能产生死锁
   产生死锁的四个必要条件

   - 互斥条件：所谓互斥就是在某一时间独占资源
   - 请求与保持条件：一个进程因请求资源而阻塞的时，对已获得的资源保持不放
   - 不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺
   - 循环等待条件：若干进程之间形成的一种头尾相接的循环等待资源关系

34. 死锁的预防
   打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态

   - 打破互斥条件，即允许进程同时访问某些资源，但是有的资源是不允许被同时访问的，像打印机等等,这是由资源本身的属性据决定的，所以这种方案并无实用价值
   - 打破不可抢占条件，即允许进程强行从占用者那里夺取，就是说当一个进程已经占有了某些资源，以后再重新申请，他所释放的资源可以分配给其他进程，这就相当于该进程占有的资源被隐蔽地强占了，这种预防死锁的方法实现起来困难，会降低系统性能

35. 什么叫守护线程，用什么方法实现守护线程
   守护进程是为其他线程的运行提供服务的进程；setDaemon（boolean on）方法的设置线程的Daemon模式，ture为守护模式，false为用户模式

36. java线程池技术与原理

37. java并发包concurrent及常用的类

38. volatile关键字

39. java中的NIO、BIO、AIO分别是什么

   - BIO 同步并阻塞，服务器实现模式为一个连接一个线程，即服务端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的进程开销。可以通过线程池机制改善，BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前唯一的选择，但程序简单直观容易理解
   - NIO 同步非阻塞，服务器实现模式为一个请求一个进程，即客户端发送的连接请求都会注册到多路复用器上。多路复用器轮询到连接有I/O请求时才启动一个线程进行处理，NIO方式适应于连接数目多且连接比较短的架构，jdk1.4后开始支持
   - AIO 异步无阻塞，服务器实现模式为一个有效请求一个进程，客户端的IO请求都是由OS先完成了再3通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，JDK1.7后开始支持

40. IO与NIO的区别

   - IO是面向流的，NIO是面向缓冲区的
   - IO的各种流是阻塞的，NIO是非缓冲模式
   - java NIO的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来选择通道，这些通道里已经有可以处理的输入，或者选择已准备写入的通道，这种选择机制，使得一个单独的线程很容易管理管理多个线程

41. 序列化与反序列化

   - 把对象转换为字节序列的过程称为对象的序列化
   - 把字节序列恢复为对象的过程称为对象的反序列化

   对象的序列化主要有两个用途

   - 把对象的字节序列永久地保存到硬盘上，通常存放到一个文件
   - 在网络上传送对象的字节序列
   - 当两个进程在进行远程通信的时候，彼此可以发送各种类型的数据，无论是何种类型的数据，都会以二进制序列的形式

42. 常见的序列化协议
   Protobuf，Thrift，Hessian，Kryo

43. 内存溢出与内存泄漏的区别
   内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory
   内存泄漏是指分配出去的内存不再使用，但是无法回收

44. java内存模型及各个区域的OOM，如何重现OOM

45. 出现OOM如何解决

46. 用什么工具可以查出内存泄漏

47. java内存管理及回收算法

48. java类加载器及如何加载类（双亲委派）

49. xml解析方式

   - DOM（jaxp Crimson解析器）
   - SAX
   - JDOM
   - DOM4J

50. Statement和PreparedStatement之间的区别

   - PreparedStatement是预编译的，对于批量处理可以大大提高效率，也叫jdbc存储过程
   - 使用 Statement 对象。在对数据库只执行一次性存取的时侯，用 Statement 对象进行处理。PreparedStatement 对象的开销比Statement大，对于一次性操作并不会带来额外的好处。
   - statement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得, preparedstatement支持批处理

51. Java中的接口

   - 接口（interface）是一个抽象类型，是抽象方法的集合，一个类通过继承接口的方法，从而继承接口的抽象方法
   - 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

## JavaEE

1. servlet生命周期及各个方法

2. servlet如何自定义filter

3. jsp原理

4. jsp和Servlet的区别
   - jsp经过编译之后就变成了“类servlet”
   - jsp由html代码和jsp标签构成，更擅长页面显示；servlet更擅长流程控制
   - jsp中嵌入java代码，而servlet中嵌入HTML代码

5. Jsp的动态include和静态include
   - 动态include用jsp：include动作实现，如<jsp:include page="abc.jsp" flush="true" />，它总是会检查所含文件的变化，适合包含动态页面，解析后和主页面一并显示，即先编译后包含
   - 静态include用include伪码实现，不会检查所含文件的变化，适用于包含静态界面，如<%@ include file="qq.htm" %>，不会提前解析所要包含的界面，先把要显示的界面包含进来，然后统一编译，即先包含再编译

6. Struts中的请求处理

7. MVC概念

8. Spring  mvc与Struts区别

9. HIbernate/Ibatis两者的区别

10. HIbernate一级和二级缓存

11. HIbernate实现集群部署

12. HIbernate如何实现声明式事务

13. 简述HIbernate常见的优化策略

14. Spring bean的加载过程

15. Spring如何实现AOP和IOC

16. Spring bean注入方式

17. Spring的事务管理

18. Spring事务的传播特性

19. springmvc原理

20. springmvc用过哪些注解

21. Restful有几种请求

22. Restful好处

23. Tomcat、Apache、JBoss的区别
    - Apache：HTTP服务器（web服务器），类似iis，可以用于建立虚拟站点，编译处理静态页面，可以支持ssl技术，支持多个虚拟主机等功能
    - Tomcat：Servlet容器，用于解析jsp，servlet的servlet容器，是高效、轻量级的容器，缺点是不支持EJB，只能用于Java应用
    - Jboss：应用服务器，运行EJB的就、J2EE的应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA等，其对Servlet的支持是通过其他Servlet容器实现的，如tomcat和jetty

24. memcached和redis的区别

25. 有没有聚遇到中文乱码问题，如何解决

26. 如何理解分布式锁

27. 你知道的开源协议

28. json和xml的区别
    xml：

    - 应用广泛，可拓展性强，被广泛应用于各种场合
    - 读取、解析没有json快
    - 可读性强，可描述复杂结构

    json：

    - 结构简单，都是键值对
    - 读取，解析快，很多语言支持
    - 传输数据量少。传递效率大大提高
    - 描述复杂结构较弱

## 设计模式

1. 设计模式的六大原则
2. 常见的设计模式
3. 用一个设计模式写一段代码或画出一个设计模式的UML
4. 如何理解MVC
5. 高内聚低耦合的理解

## 算法

1. 深度优先、广度优先算法
2. 排序算法及对应的时间复杂度和空间复杂度
3. 写一个排序算法
4. 查找算法
5. B+树和二叉树查找时间复杂度
6. KMP算法、hash算法
7. 常见的hash算法
8. 如何判断一个单链表是否有环
9. 给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少
10. 给你一个数组，如何找到里面和为K的两个数
11. 一堆数字里面继续去重，要怎么处理

## 数据结构

队列、栈、链表、树、堆、图；编码实现队列、栈

## linux

1. linux常用命令
2. 如何查看内存使用情况
3. linux下如何进行进程调度

## 操作系统

1. 操作系统什么情况下会死锁
2. 产生死锁的必要条件
3. 死锁预防

## 安全

1. 如果客户端不断发送请求会怎么样
2. DDOS攻击
3. DDOS预防
4. 怎么知道连接是恶意的？可能是正常连接

## 其他

1. 说一个参与的项目、其中作为什么角色
2. 遇到最困难的问题是什么，怎么解决的
3. 自己有哪些不足
4. 平常如何学习的
5. 如何评价自己

## 智力题

1. 给你50个红球和50个黑球，有两个一模一样的桶，往桶里放球，让朋友随机去抽，采用什么策略可以让朋友抽到的红球概率更高？
2. 从100个硬币中找出最轻的哪个假币









