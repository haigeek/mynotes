# gitlab项目fork步骤

## 现有的fork和开发步骤

### fork步骤

1. 项目负责人新建好仓库文件夹，前端（front-end）、后台（back-end）、计算（gis）
2. 找到基线仓库地址，点击fork按钮会出现要fork到的目标仓库，可以使用ctrl+f输入项目编码快速找到目标仓库，注意看准项目编码后的文件夹名称，例如SH2019GH081/back-end，才是要fork的位置
3. fork完成之后对fork完成的项目进行定制修改。

### 开发步骤

在fork完成之后，删除无用的tag和分支，保留这次版本所使用的分支，在这里分两种情况，使用最新版本或者历史版本

#### 使用最新版本

1. 当使用最新版本时，基线的master分支即我们所需要的版本，对于fork过来的仓库，分支只保留一个master分支，也代表着项目的默认分支为master

2. clone项目到本地并checkout出开发分支。clone命令默认会clone默认分支到本地

   ```
   # clone 指定分支到本地，此时会在本地生成一个名为master的本地分支
   git clone http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335/xdata/SH2018GH036/back-end/dgp-dubbo-server-root.git
   # 基于master checkout出dev分支
   git checkout -b dev
   ```

3. 在checkout出的本地分支的readme中记录此次版本发布信息（包括使用的版本以及要进行开发的分支），此步骤的目的是为了记录地方项目开发的开始，与基线版本已经分离。并将此dev分支push到远程供大家开发

   ```
   git push origin dev
   ```

4. 版本发布人员在完成上述操作之后，开发人员使用下述命令进行新建dev分支并进行后续的开发

   ```
   git checkout -b dev origin/dev
   ```

#### 使用历史版本

1. 当使用历史版本时候，目前的机制是存在一个历史版本分支，例如使用20191230的版本，就只保留release-2.8.0-20191230，此处需要做一个调整，在仓库设置中将release-2.8.0-20191230作为默认分支（相当于master分支），取消master分支的默认分支属性并删除（master分支超前，已经不再适用）
2. 后续2、3、4与使用最新版本的操作相同

## 改进建议

目前的基线的分支比较多，有些有用有些没用， 每个版本也有一个分支，这些只在基线开发的时候是可以满足需求，但是fork到地方的项目的时候这些分支都要删除，虽然工作量不大，但是还是有些繁琐。有以下几点建议：

1. 基线废弃的分支可以删除,因为git分支的理念就是开发完成合并之后删除，当然也存在一些不是为了功能开发而建立的分支，类似副分支的作用，例如
2. 使用tag进行版本发布,使用分支作为版本管理虽然可以满足需求，但是过多的分支对于fork出去的项目是无用的
3. fork出去的项目最好也能有自己的master分支并使用起来（结合我们的版本发布来看，不一定叫master），因为项目的模块可能有自己特有的子系统（从0到1），那么只有dev的话，也就不存在一个稳定的版本分支了。

## 改进后的fork和开发步骤

首先最终改进的最终成果为：

1. 功能分支都是有用的，没有废弃分支
2. 不会随着时间的推移，产生大量的版本分支

假设我们改进之后基线只有master、dev、hotfix、feature-xxx分支（尽可能少，合并完成之后尽快删除），具有每个版本的tag，那么相比现在的步骤有以下变化

1. fork步骤不变

2. 不论是使用最新版本还是历史版本，统一只保留一个master分支（必须存在一个分支）

3. 针对使用最新版本的项目，步骤不变

4. 对于使用历史版本的项目，在clone项目之后，基于版本tag创建版本主分支，并基于此分支创建dev分支

   ```
   # git branch <new-branch-name> <tag-name> 创建版本主分支
   git branch 20191230 V20191230
   # 切换到创建出的版本分支
   git checkout 20191230
   # 创建开发分支
   git checkout -b dev
   ```

   在dev分支记录必要信息，并将新创建的dev和版本分支push到远程，将版本分支作为默认分支，删除原有的master分支。完成这些操作之后，后续操作不变

