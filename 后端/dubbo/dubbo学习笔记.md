## 集群容错
在集群调用失败的时候,Dubbo提供了多种容错方案，缺省为failover重试
- invoker invoker是Provider的一个可调用的service的抽象，Invoker封装了Provider的地址以及Service接口信息
- Directory Directory代表多个Invoker，可以看作是List<invoker>,与List不同的是，它的值可能是动态变化的，比如注册中心推送变更
- Cluster 将 Directory 中的多个 Invoker 伪装成⼀个 Invoker ，对上层透明，伪装过程包含了容错逻辑，调⽤失败后，重试另⼀个
- Router 负责从多个 Invoker 中按路由规则选出⼦集，⽐如读写分离，应⽤隔离等
- LoadBalance 负责从多个 Invoker 中选出具体的⼀个⽤于本次调⽤，选的过程包含了负载均衡算法，调⽤失败后，需要重选
## 负载均衡
在集群负载均衡的时候，Dubbo提供了多种均衡策略，缺省为`random`随机调用
## 线程模型
如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，则直接在 IO 线程上处理更快，因为减少了线程池调度。但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，⽐如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。
如果⽤ IO 线程处理事件，⼜在事件处理过程中发起新的 IO 请求，⽐如在连接事件中发起登录请求，会报可能引发死锁异常，但不会真死锁。因此需要不同的派发策略和不同的线程池配置来应对不同的场景
### Dispacther
### ThreaPool
## 直连提供者
在开发及测试环境下，需要绕过注册中心，只测试服务提供者，这时候需要点对点直连，以服务接口为单位，忽略注册中心的提供者列表，A 接⼝配置点对点，不影响 B 接⼝从注册中⼼获取列表
- 通过xml配置
- 通过- D 参数指定
- 通过文件映射
## 只订阅&只注册
## 静态服务
人工管理服务提供者的上线和下线，此时需要将注册中心标识为非动态管理模式
服务提供者初次注册时为禁⽤状态，需⼈⼯启⽤。断线时，将不会被⾃动删除，需⼈⼯禁⽤
## 多协议
Dubbo 允许配置多协议，在不同服务上⽀持不同协议或者同⼀服务上同时⽀持多种协议。不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议
## 多注册中心
Dubbo支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册节点上
## 服务分组
当一个接口有多种实现的时候，可以用group区分
## 多版本
当一个接口实现，出现不兼容升级的时候，可以用版本号过渡，版本号不同的服务相互间不引用
## 分组聚合
按组合并并返回结果⽐如菜单服务，接⼝⼀样，但有多种实现，⽤group区分，现在消费⽅需从每种group中调⽤⼀次返回结果，合并结果返回，这样就可以实现聚合菜单项。
## 参数验证
参数验证是基于JSR303实现的，用户只需标识JSR303标准验证的annotation，并通过声明filter来实现验证
## 结果缓存
结果缓存，用于加速热门数据的访问速度，Dubbo提供声明式缓存，以减少用户加缓存的工作量
## 泛化引用
## 泛化实现
## 回声测试
回声测试⽤于检测服务是否可⽤，回声测试按照正常请求流程执⾏，能够测试整个调⽤是否通畅，可⽤于监控。
所有服务⾃动实现 EchoService 接⼝，只需将任意服务引⽤强制转型为 EchoService ，即可使⽤。
## 上下文信息
上下文存放的是当前调用过程中所需的环境信息，所有配置信心都将转换为URl的参数
## 隐式参数
可以通过RpcContext上的setAttachment和getAttachment，在服务消费方和提供方进行参数的隐式传递
## 异步调用
基于NIO的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较少
## 本地调用
本地调用使用了一个injvm协议，塔不开启端口，不发起远程调用，只在jvm内直接关联，但执行Dubbo的Filter链
## 自动暴露、引用本地服务
从 2.2.0 开始，每个服务默认都会在本地暴露。在引⽤服务的时候，默认优先引⽤本地服务。如果希望引⽤远程服务可以使⽤⼀下配置强制引⽤远程服务。
## 参数回调
参数回调⽅式与调⽤本地 callback 或 listener 相同，只需要在 Spring 的配置⽂件中声明哪个参数是 callback 类型即可。Dubbo 将基于⻓连接⽣成反向代理，这样就可以从服务器端调⽤客户端逻辑
